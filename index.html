<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Hologram — Core + Dynamic (Auto CPU/GPU) • Debug</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <style>
    html,body{height:100%;margin:0;background:#000;color:#fff;font-family:Monospace}
    #info{position:absolute;top:10px;left:0;right:0;text-align:center;z-index:10;pointer-events:none}
    #container{width:100vw;height:100vh}
    #err{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);max-width:90%;color:#f66;font:13px monospace;white-space:pre-wrap}
    #log{position:fixed;left:10px;bottom:10px;z-index:20;font:12px monospace;color:#ddd;white-space:pre;pointer-events:none}
    .ok{color:#9f9}.bad{color:#f99}.hidden{display:none}
  </style>

  <!-- Import map so addons can `import 'three'` -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.167.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.167.0/examples/jsm/"
    }
  }
  </script>

  <!-- Defaults (override with ?asset=&track=) -->
  <script>
    window.ASSET_BASE_URL = "https://pub-e80d414bc7df438287d3018cdba68570.r2.dev";
    window.TRACK_ID       = "demo_v1";
    try {
      const q = new URLSearchParams(location.search);
      if (q.get('asset')) window.ASSET_BASE_URL = q.get('asset');
      if (q.get('track')) window.TRACK_ID = q.get('track');
    } catch {}

    // Error overlays
    addEventListener('error', e=>{
      const d=document.getElementById('err')||document.body.appendChild(Object.assign(document.createElement('div'),{id:'err'}));
      d.textContent='JS Error: '+(e.error?.stack || e.message);
    });
    addEventListener('unhandledrejection', e=>{
      const d=document.getElementById('err')||document.body.appendChild(Object.assign(document.createElement('div'),{id:'err'}));
      d.textContent='Promise Error: '+(e.reason?.stack || e.reason);
    });
  </script>

  <!-- libs -->
  <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
</head>
<body>
  <div id="info">Hologram — Preprocessed Points • Initializing…</div>
  <div id="container"></div>
  <div id="log"></div>

  <script type="module">
    // ---------- status log ----------
    const logEl=document.getElementById('log');
    const log=(m,ok=true)=>{ const s=document.createElement('div'); s.className=ok?'ok':'bad'; s.textContent=(ok?'✓ ':'✗ ')+m; logEl.appendChild(s); console[ok?'log':'warn'](m); };
    if (!HTMLScriptElement.supports?.('importmap')) log('Browser lacks importmap support', false);
    log('boot');

    // ---------- modules ----------
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { XRButton } from "three/addons/webxr/XRButton.js";
    import { XRControllerModelFactory } from "three/addons/webxr/XRControllerModelFactory.js";
    import { OculusHandModel } from "three/addons/webxr/OculusHandModel.js";
    import { PLYLoader } from "three/addons/loaders/PLYLoader.js";
    log('modules ok');

    // ---------- config ----------
    const ASSET_BASE_URL=(window.ASSET_BASE_URL||'').trim();
    const TRACK_ID=(window.TRACK_ID||'').trim();
    const manifestUrl=`${ASSET_BASE_URL}/${TRACK_ID}/manifest.json`;

    // ---------- capability detect ----------
    let CAPS = { isWebGL2:false, vtf:false };
    let USE_GPU = false; // decide after renderer exists
    function detectCaps(renderer){
      const gl = renderer.getContext();
      const isWebGL2 = renderer.capabilities.isWebGL2 === true;
      let maxVTF = 0;
      try { maxVTF = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) || 0; } catch {}
      return { isWebGL2, vtf: (isWebGL2 && maxVTF > 0) || maxVTF > 0 };
    }

    // ---------- globals ----------
    let scene,camera,renderer,controls,mainScene;
    let corePoints=null,coreMat=null,dynPoints=null,dynMat=null;
    let header=null,posBuf=null,colBuf=null;
    let numFrames=0,fps=8,numPoints=0;
    let qOff=new THREE.Vector3(), qScale=new THREE.Vector3();
    let stridePos=0,strideCol=0;
    let dtPos=null,dtCol=null,tmpPosF32=null; // GPU textures

    // CPU animated baseline buffers/attrs
    let dynPosAttr=null, dynColAttr=null;
    let dynPosArray=null, dynColArray=null; // Float32Array we mutate per frame
    let selectedIdx = null; // decimation map (indices to keep)

    // params
    const params={ size:6, coreOpacity:1.0, dynOpacity:1.0 };
    const quality={ density:1.0, maxFPS:60 };
    const playback={ play:true, frame:0 };

    // ---------- utils ----------
    async function j(url){ const r=await fetch(url); if(!r.ok) throw new Error(`${r.status} ${url}`); return r.json(); }
    async function b(url){ const r=await fetch(url); if(!r.ok) throw new Error(`${r.status} ${url}`); return r.arrayBuffer(); }

    function f16_to_f32(h){ const s=(h&0x8000)>>15,e=(h&0x7C00)>>10,f=h&0x03FF;
      if(!e) return (s?-1:1)*Math.pow(2,-14)*(f/1024);
      if(e===31) return f?NaN:((s?-1:1)*Infinity);
      return (s?-1:1)*Math.pow(2,e-15)*(1+f/1024);
    }
    function convertF16Block(u16,out){ for(let i=0;i<u16.length;i++) out[i]=f16_to_f32(u16[i]); return out; }

    function texRGBA32F_fromRGBArray(arr,count){
      const rgba=new Float32Array(count*4);
      for(let i=0,j=0;i<count*3;i+=3,j+=4){ rgba[j]=arr[i]; rgba[j+1]=arr[i+1]; rgba[j+2]=arr[i+2]; rgba[j+3]=1.0; }
      const t=new THREE.DataTexture(rgba,count,1,THREE.RGBAFormat,THREE.FloatType);
      t.needsUpdate=true; t.magFilter=t.minFilter=THREE.NearestFilter; t.wrapS=t.wrapT=THREE.ClampToEdgeWrapping; return t;
    }
    
    function idsGeom(n){ 
      const g=new THREE.BufferGeometry(); 
      const ids=new Float32Array(n); 
      for(let i=0;i<n;i++) ids[i]=i; 
      g.setAttribute('a_id',new THREE.BufferAttribute(ids,1)); 
      // Dummy position attribute so Three.js knows the vertex count for gl.POINTS
      const pos = new Float32Array(n*3);
      g.setAttribute('position', new THREE.BufferAttribute(pos,3));
      return g; 
    }


    function fitCameraToObject(obj,pad=1.3){
      obj.geometry.computeBoundingSphere?.();
      const bs=obj.geometry.boundingSphere;
      if(!bs){ log('no bounding sphere',false); return; }
      const r=bs.radius*pad;
      camera.position.set(bs.center.x,bs.center.y,bs.center.z + r*2.8);
      camera.near=Math.max(0.01,r/100); camera.far=r*25; camera.updateProjectionMatrix();
      controls.target.copy(bs.center);
      log(`camera fit r=${r.toFixed(2)}`);
    }

    // Round sprite for PointsMaterial
    function circleSprite(size=64){
      const c=document.createElement('canvas'); c.width=c.height=size;
      const g=c.getContext('2d');
      g.clearRect(0,0,size,size);
      g.beginPath(); g.arc(size/2,size/2,size*0.48,0,Math.PI*2); g.closePath();
      g.fillStyle='white'; g.fill();
      const tx = new THREE.CanvasTexture(c);
      tx.magFilter = THREE.LinearFilter; tx.minFilter = THREE.LinearMipMapLinearFilter;
      tx.wrapS = tx.wrapT = THREE.ClampToEdgeWrapping;
      return tx;
    }
    const DISC_TEX = circleSprite();

    // ---------- shaders (GPU path) ----------
    const dynVS=`attribute float a_id; uniform sampler2D u_positions; uniform vec3 u_off,u_scale; uniform float u_size,u_n; varying float v_id;
      void main(){ float u=(a_id+0.5)/u_n; vec3 pN=texture2D(u_positions,vec2(u,0.5)).rgb; vec3 p=u_off+u_scale*pN;
      vec4 v=viewMatrix*vec4(p,1.0); gl_Position=projectionMatrix*v; float s=length(vec3(modelMatrix[0])); gl_PointSize=u_size*s*(1.0/-v.z); v_id=a_id; }`;
    const dynFS=`uniform sampler2D u_colors; uniform float u_n,u_opacity; varying float v_id;
      void main(){ if(length(gl_PointCoord-vec2(0.5))>0.5) discard; float u=(v_id+0.5)/u_n; vec3 c=texture2D(u_colors,vec2(u,0.5)).rgb; gl_FragColor=vec4(c,u_opacity); }`;
    const coreVS=`attribute vec3 position; attribute vec3 color; uniform float u_size; varying vec3 v_c;
      void main(){ vec4 v=viewMatrix*vec4(position,1.0); gl_Position=projectionMatrix*v; float s=length(vec3(modelMatrix[0])); gl_PointSize=u_size*s*(1.0/-v.z); v_c=color; }`;
    const coreFS=`uniform float u_opacity; varying vec3 v_c; void main(){ if(length(gl_PointCoord-vec2(0.5))>0.5) discard; gl_FragColor=vec4(v_c,u_opacity);} `;

    // ---------- scene ----------
    function setupScene(){
      const container=document.getElementById('container');
      scene=new THREE.Scene();
      camera=new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.01, 1e6);
      camera.position.set(0,0,3);
      renderer=new THREE.WebGLRenderer({antialias:true,alpha:true});
      renderer.setPixelRatio(devicePixelRatio); renderer.setSize(innerWidth,innerHeight);
      renderer.xr.enabled=true; renderer.setClearColor(0x111111,1);
      container.appendChild(renderer.domElement);
      controls=new OrbitControls(camera,renderer.domElement);
      controls.enableDamping=true; controls.dampingFactor=0.05;

      // caps & path
      CAPS = detectCaps(renderer);
      USE_GPU = CAPS.vtf; // only use GPU path if VTF available
      log(`caps: webgl2=${CAPS.isWebGL2} vtf=${CAPS.vtf}`);
      // Optional URL override: ?force=cpu | ?force=gpu
      try {
        const q = new URLSearchParams(location.search);
        const f = (q.get('force')||'').toLowerCase();
        if (f === 'cpu') {
          USE_GPU = false;
          log('force=cpu active');
        } else if (f === 'gpu') {
          if (!CAPS.vtf) { log('force=gpu requested but VTF not available — falling back to CPU', false); USE_GPU=false; }
          else { USE_GPU = true; log('force=gpu active'); }
        }
      } catch (e) { /* ignore */ }

      log(USE_GPU ? 'using GPU texture path' : 'using CPU baseline path');

      document.getElementById('info').textContent =
        `Hologram — Preprocessed Points • ${USE_GPU ? 'GPU' : 'CPU'} path`;

      // Optional XR objects (kept but not critical)
      document.body.appendChild(XRButton.createButton(renderer,{requiredFeatures:[]}));
      const xmf=new XRControllerModelFactory(); const g1=renderer.xr.getControllerGrip(0); g1.add(xmf.createControllerModel(g1)); scene.add(g1);
      const g2=renderer.xr.getControllerGrip(1); g2.add(xmf.createControllerModel(g2)); scene.add(g2);
      const h1=renderer.xr.getHand(0); h1.add(new OculusHandModel(h1)); scene.add(h1);
      const h2=renderer.xr.getHand(1); h2.add(new OculusHandModel(h2)); scene.add(h2);

      mainScene=new THREE.Object3D(); scene.add(mainScene);
      addEventListener('resize',()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight); });
    }

    // ---------- GUI ----------
    function setupGUI() {
      const gui = new dat.GUI();

      const sizeCtrl = gui.add(params, "size", 1, 200).name("Point Size");
      sizeCtrl.onChange(v => {
        if (coreMat?.isShaderMaterial) coreMat.uniforms.u_size.value = v;
        if (dynMat?.isShaderMaterial)  dynMat .uniforms.u_size.value = v;
        if (coreMat?.isPointsMaterial) coreMat.size = v;
        if (dynMat ?.isPointsMaterial) dynMat .size = v;
      });

      const coreCtrl = gui.add(params, "coreOpacity", 0.0, 1.0).name("coreOpacity");
      coreCtrl.onChange(v => {
        if (coreMat?.isShaderMaterial) coreMat.uniforms.u_opacity.value = v;
        if (coreMat?.isPointsMaterial) coreMat.opacity = v;
      });

      const dynCtrl  = gui.add(params, "dynOpacity", 0.0, 1.0).name("dynOpacity");
      dynCtrl.onChange(v => {
        if (dynMat?.isShaderMaterial) dynMat.uniforms.u_opacity.value = v;
        if (dynMat?.isPointsMaterial) dynMat.opacity = v;
      });

      const visFolder = gui.addFolder("Visibility");
      const vis = { core:true, dynamic:true };
      visFolder.add(vis, "core").onChange(v => { if (corePoints) corePoints.visible = v; });
      visFolder.add(vis, "dynamic").onChange(v => { if (dynPoints)  dynPoints.visible  = v; });
      visFolder.open();

      const colorOpts = { useVertexColors: true, tint: [255,255,255] };
      const colFolder = gui.addFolder("Color");
      colFolder.add(colorOpts, "useVertexColors").name("Use Vertex Colors").onChange(v=>{
        if (coreMat?.isPointsMaterial) { coreMat.vertexColors = v; coreMat.needsUpdate = true; }
        if (dynMat ?.isPointsMaterial) { dynMat .vertexColors = v; dynMat .needsUpdate = true; }
      });
      colFolder.addColor(colorOpts, "tint").name("Tint").onChange(rgb=>{
        const c = new THREE.Color(rgb[0]/255, rgb[1]/255, rgb[2]/255);
        if (coreMat?.isPointsMaterial) coreMat.color.copy(c);
        if (dynMat ?.isPointsMaterial) dynMat .color.copy(c);
      });
      colFolder.open();

      const qFolder = gui.addFolder("Quality");
      qFolder.add(quality, "density", { "25%":0.25, "50%":0.5, "100%":1.0 }).name("Density").onChange(()=>rebuildDynamicGeometry());
      qFolder.add(quality, "maxFPS", { "15":15, "30":30, "60":60 }).name("Max FPS");
      qFolder.open();

      const pbFolder = gui.addFolder("Playback");
      pbFolder.add(playback, "play").name("Play/Pause");
      pbFolder.add({ next:()=>{ if (header) { playback.play=false; playback.frame = (playback.frame+1)%numFrames; } }}, "next").name("Next Frame");
      pbFolder.add({ prev:()=>{ if (header) { playback.play=false; playback.frame = (playback.frame-1+numFrames)%numFrames; } }}, "prev").name("Prev Frame");
      pbFolder.open();

      window.addEventListener("keydown", e => { if (e.key.toLowerCase() === "g") gui.domElement.classList.toggle("hidden"); });
    }

    // ---------- loaders ----------
    async function loadCore(m){
      if (!m.staticCore?.url) return null;
      const url=`${ASSET_BASE_URL}/${TRACK_ID}/${m.staticCore.url}`;
      const ab=await b(url);
      const inflated=pako.inflate(new Uint8Array(ab));
      const text=new TextDecoder().decode(inflated);  // ASCII PLY
      const g=new PLYLoader().parse(text);

      const ca=g.getAttribute('color');
      if(ca && ca.array instanceof Uint8Array){
        const n=ca.count; const f=new Float32Array(n*3);
        for(let i=0;i<n*3;i++) f[i]=ca.array[i]/255;
        g.setAttribute('color',new THREE.BufferAttribute(f,3));
      } else if(!ca){
        const n=g.getAttribute('position').count; const ones=new Float32Array(n*3); ones.fill(1);
        g.setAttribute('color',new THREE.BufferAttribute(ones,3));
      }

      if (USE_GPU) {
        coreMat = new THREE.ShaderMaterial({
          uniforms:{ u_size:{value:params.size}, u_opacity:{value:params.coreOpacity} },
          vertexShader: coreVS, fragmentShader: coreFS, transparent:true, depthWrite:false
        });
      } else {
        coreMat = new THREE.PointsMaterial({
          size: params.size, sizeAttenuation:true,
          vertexColors: !!g.getAttribute('color'),
          opacity: params.coreOpacity, transparent:true, depthWrite:false,
          map: DISC_TEX, alphaTest: 0.5
        });
      }
      const pts=new THREE.Points(g,coreMat); pts.frustumCulled=false;
      return pts;
    }

    function buildSelectedIdx(){
      const step = Math.max(1, Math.floor(1/quality.density));
      const idx = [];
      for (let i=0;i<numPoints;i+=step) idx.push(i);
      selectedIdx = idx;
    }

    async function loadChunk(path){
      header = await j(`${ASSET_BASE_URL}/${TRACK_ID}/${path}header.json`);
      const {numFrames:fN=0,fps:fpsIn=8,numPoints:nPts=0,quant}=header;
      numFrames=fN; fps=fpsIn; numPoints=nPts;
      qOff.set(...quant.offset); qScale.set(...quant.scale);

      const [pb,cb]=await Promise.all([
        b(`${ASSET_BASE_URL}/${TRACK_ID}/${path}positions.bin`),
        b(`${ASSET_BASE_URL}/${TRACK_ID}/${path}colors.bin`)
      ]);
      posBuf=pb; colBuf=cb;
      stridePos=numPoints*3*2; strideCol=numPoints*3;
      tmpPosF32=new Float32Array(numPoints*3);

      buildSelectedIdx(); // based on current density

      if (USE_GPU) {
        const geom=idsGeom(numPoints);
        dynMat=new THREE.ShaderMaterial({
          uniforms:{
            u_positions:{value:null}, u_colors:{value:null},
            u_off:{value:qOff}, u_scale:{value:qScale},
            u_size:{value:params.size}, u_n:{value:numPoints}, u_opacity:{value:params.dynOpacity}
          },
          vertexShader: dynVS, fragmentShader: dynFS, transparent:true, depthWrite:false
        });
        dynPoints=new THREE.Points(geom,dynMat); dynPoints.frustumCulled=false;
        updateFrameTextures(0);
        dynMat.uniforms.u_positions.value=dtPos;
        dynMat.uniforms.u_colors.value   =dtCol;
        return dynPoints;
      } else {
        // CPU baseline geom using selected indices
        const geom = new THREE.BufferGeometry();
        const N = selectedIdx.length;
        dynPosArray = new Float32Array(N*3);
        dynColArray = new Float32Array(N*3);

        // Fill first frame
        const u16 = new Uint16Array(posBuf, 0, numPoints*3);
        for (let k=0;k<N;k++){
          const i = selectedIdx[k];
          const base = i*3;
          for (let a=0;a<3;a++){
            const n = f16_to_f32(u16[base+a]);
            dynPosArray[k*3+a] = qOff.getComponent(a) + qScale.getComponent(a) * n;
          }
        }
        const u8 = new Uint8Array(colBuf, 0, numPoints*3);
        for (let k=0;k<N;k++){
          const i = selectedIdx[k];
          const base = i*3;
          dynColArray[k*3+0] = u8[base+0]/255;
          dynColArray[k*3+1] = u8[base+1]/255;
          dynColArray[k*3+2] = u8[base+2]/255;
        }

        dynPosAttr = new THREE.BufferAttribute(dynPosArray, 3);
        dynColAttr = new THREE.BufferAttribute(dynColArray, 3);
        geom.setAttribute('position', dynPosAttr);
        geom.setAttribute('color', dynColAttr);

        dynMat = new THREE.PointsMaterial({
          size: params.size, sizeAttenuation:true,
          vertexColors:true, opacity: params.dynOpacity, transparent:true, depthWrite:false,
          map: DISC_TEX, alphaTest: 0.5
        });
        dynPoints = new THREE.Points(geom, dynMat);
        dynPoints.frustumCulled = false;
        return dynPoints;
      }
    }

    function updateFrameTextures(i){
      const u16=new Uint16Array(posBuf, i*stridePos, numPoints*3);
      const u8 =new Uint8Array (colBuf, i*strideCol, numPoints*3);
      convertF16Block(u16,tmpPosF32);
      if(!dtPos) dtPos=texRGBA32F_fromRGBArray(tmpPosF32,numPoints);
      else {
        const rgba=dtPos.image.data;
        for(let p=0,q=0;p<numPoints*3;p+=3,q+=4){ rgba[q]=tmpPosF32[p]; rgba[q+1]=tmpPosF32[p+1]; rgba[q+2]=tmpPosF32[p+2]; rgba[q+3]=1.0; }
        dtPos.needsUpdate=true;
      }
      if(!dtCol){
        dtCol=new THREE.DataTexture(new Uint8Array(u8),numPoints,1,THREE.RGBFormat,THREE.UnsignedByteType);
        dtCol.needsUpdate=true; dtCol.magFilter=dtCol.minFilter=THREE.NearestFilter; dtCol.wrapS=dtCol.wrapT=THREE.ClampToEdgeWrapping;
      } else {
        dtCol.image.data.set(new Uint8Array(u8)); dtCol.needsUpdate=true;
      }
    }

    function rebuildDynamicGeometry(){
      if (!header || USE_GPU || !dynPoints) return;
      // Rebuild CPU arrays according to new density
      buildSelectedIdx();
      const N = selectedIdx.length;
      dynPosArray = new Float32Array(N*3);
      dynColArray = new Float32Array(N*3);
      dynPosAttr = new THREE.BufferAttribute(dynPosArray,3);
      dynColAttr = new THREE.BufferAttribute(dynColArray,3);
      dynPoints.geometry.setAttribute('position', dynPosAttr);
      dynPoints.geometry.setAttribute('color', dynColAttr);
      // Force an immediate refresh for current frame
      updateCPUFrame(currentFrameIndex());
    }

    // ---------- animation ----------
    const clock=new THREE.Clock(); let last=0; let acc=0;
    function nowSec(){ return performance.now()*0.001; }
    function currentFrameIndex(){
      if(!header) return 0;
      if (!playback.play) return playback.frame|0;
      const t = nowSec();
      return Math.floor(t*Math.min(quality.maxFPS, fps)) % Math.max(1,numFrames);
    }
    function updateCPUFrame(fi){
      if (!(dynPosAttr && dynColAttr)) return;
      const N = selectedIdx.length;
      const u16 = new Uint16Array(posBuf, fi*stridePos, numPoints*3);
      for (let k=0;k<N;k++){
        const i = selectedIdx[k]; const base=i*3;
        for (let a=0;a<3;a++){
          const n = f16_to_f32(u16[base+a]);
          dynPosArray[k*3+a] = qOff.getComponent(a) + qScale.getComponent(a) * n;
        }
      }
      dynPosAttr.needsUpdate = true;

      const u8 = new Uint8Array(colBuf, fi*strideCol, numPoints*3);
      for (let k=0;k<N;k++){
        const i = selectedIdx[k]; const base=i*3;
        dynColArray[k*3+0] = u8[base+0]/255;
        dynColArray[k*3+1] = u8[base+1]/255;
        dynColArray[k*3+2] = u8[base+2]/255;
      }
      dynColAttr.needsUpdate = true;
    }

    function animate(){
      const t=clock.getElapsedTime(); const dt=t-last; last=t;
      controls.update();

      if(header){
        const fi = currentFrameIndex();
        if (USE_GPU) {
          updateFrameTextures(fi);
          if(dynMat){ dynMat.uniforms.u_positions.value=dtPos; dynMat.uniforms.u_colors.value=dtCol; }
        } else {
          updateCPUFrame(fi);
        }
      }
      renderer.render(scene,camera);
    }

    // ---------- boot ----------
    (async function main(){
      setupScene();
      setupGUI();

      log('fetch manifest...');
      const manifest=await j(manifestUrl);      log('manifest ok');

      log('load core...');
      corePoints=await loadCore(manifest);
      if (corePoints){ mainScene.add(corePoints); log(`core ok (${corePoints.geometry.getAttribute('position').count|0} pts)`); }

      log('load first chunk...');
      dynPoints=await loadChunk(manifest.dynamic.chunks[0].path);
      mainScene.add(dynPoints);
      log(`chunk ok (${numPoints} dyn pts/frame @ ${fps} fps)`);

      if (corePoints) fitCameraToObject(corePoints,1.3); else fitCameraToObject(dynPoints,1.3);

      log('start loop');
      renderer.setAnimationLoop(animate);
    })().catch(err=>{
      const d=document.getElementById('err')||document.body.appendChild(Object.assign(document.createElement('div'),{id:'err'}));
      d.textContent='Init Error: '+(err.stack||err.message);
      log('init failed: '+err.message,false);
      console.error(err);
    });
  </script>
</body>
</html>
