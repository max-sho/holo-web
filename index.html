<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Hologram — Core + Dynamic Points (WebXR)</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1, user-scalable=no"/>
    <style>
      html,body{height:100%;margin:0;background:#000;color:#fff;font-family:Monospace}
      #info{position:absolute;top:10px;left:0;right:0;text-align:center;z-index:100;text-shadow:0 0 5px #000;pointer-events:none}
      #container{width:100vw;height:100vh}
    </style>
    <!-- Inline defaults so the page works immediately; Vercel envs can override -->
    <script>
      window.ASSET_BASE_URL = window.ASSET_BASE_URL ||
        "https://pub-e80d414bc7df438287d3018cdba68570.r2.dev";
      window.TRACK_ID = window.TRACK_ID || "demo_v1";
    </script>

    <!-- three.js + addons -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/"
        }
      }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
  </head>

  <body>
    <div id="info">Hologram — Preprocessed Points (Core + Dynamic) • WebXR • GPGPU FX</div>
    <div id="container"></div>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { XRButton } from "three/addons/webxr/XRButton.js";
      import { XRControllerModelFactory } from "three/addons/webxr/XRControllerModelFactory.js";
      import { OculusHandModel } from "three/addons/webxr/OculusHandModel.js";
      import { GPUComputationRenderer } from "three/addons/misc/GPUComputationRenderer.js";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      import { PLYLoader } from "three/addons/loaders/PLYLoader.js";

      // ----- CONFIG -----
      const ASSET_BASE_URL = (window.ASSET_BASE_URL || "").trim();
      const TRACK_ID = (window.TRACK_ID || "").trim();
      const manifestUrl = `${ASSET_BASE_URL}/${TRACK_ID}/manifest.json`;

      // ----- SCENE -----
      let scene, camera, renderer, controls, mainScene;
      let corePoints=null, coreMat=null, dynPoints=null, dynMat=null;
      let gpuCompute=null, positionVar=null, gpgpuPts=null, gpgpuMat=null;

      // dynamic buffers/metadata
      let header=null, posBuf=null, colBuf=null;
      let numFrames=0, fps=8, numPoints=0;
      let qOff=new THREE.Vector3(), qScale=new THREE.Vector3();
      let stridePos=0, strideCol=0;
      let dtPos=null, dtCol=null;
      let tmpPosF32=null;

      // audio (optional)
      let audioCtx=null, audioBuf=null, src=null, playing=false, muted=true, t0=0, pausedAt=0;

      // UI params
      const params={
        size: 2.0,
        coreOpacity: 1.0,
        dynOpacity: 0.35,
        showFX: true,
        fxLife: 5.0, fxSpeed: 40.0, fxOpacity: 0.25,
        curlAmp: 40.0, curlFreq: 0.005,
        handForce: -220.0, handRadius: 0.5,
        additive: true,
        playPause: ()=>{}, mute: ()=>{}
      };

      // ----- UTIL -----
      async function j(url){ const r=await fetch(url); if(!r.ok) throw new Error(`${r.status} ${url}`); return r.json(); }
      async function b(url){ const r=await fetch(url); if(!r.ok) throw new Error(`${r.status} ${url}`); return r.arrayBuffer(); }

      function f16_to_f32(h){ const s=(h&0x8000)>>15,e=(h&0x7C00)>>10,f=h&0x03FF;
        if(!e) return (s?-1:1)*Math.pow(2,-14)*(f/1024);
        if(e===31) return f?NaN:((s?-1:1)*Infinity);
        return (s?-1:1)*Math.pow(2,e-15)*(1+f/1024);
      }
      function convertF16Block(u16, out){ for(let i=0;i<u16.length;i++) out[i]=f16_to_f32(u16[i]); return out; }

      function texRGB32F(arr, count){
        const t=new THREE.DataTexture(new Float32Array(arr.buffer), count, 1, THREE.RGBFormat, THREE.FloatType);
        t.needsUpdate=true; t.magFilter=t.minFilter=THREE.NearestFilter; t.wrapS=t.wrapT=THREE.ClampToEdgeWrapping; return t;
      }
      function texRGB8(u8, count){
        const t=new THREE.DataTexture(new Uint8Array(u8), count, 1, THREE.RGBFormat, THREE.UnsignedByteType);
        t.needsUpdate=true; t.magFilter=t.minFilter=THREE.NearestFilter; t.wrapS=t.wrapT=THREE.ClampToEdgeWrapping; return t;
      }
      function idsGeom(count){ const g=new THREE.BufferGeometry(); const ids=new Float32Array(count); for(let i=0;i<count;i++) ids[i]=i; g.setAttribute("a_id", new THREE.BufferAttribute(ids,1)); return g; }

      // ----- SHADERS -----
      const dynVS=`
        attribute float a_id;
        uniform sampler2D u_positions;
        uniform vec3 u_off, u_scale;
        uniform float u_size, u_n;
        varying float v_id;
        void main(){
          float u=(a_id+0.5)/u_n;
          vec3 pN=texture2D(u_positions, vec2(u,0.5)).rgb;
          vec3 p=u_off + u_scale * pN;
          vec4 v=viewMatrix*vec4(p,1.0);
          gl_Position=projectionMatrix*v;
          float s=length(vec3(modelMatrix[0]));
          gl_PointSize=u_size*s*(1.0/-v.z);
          v_id=a_id;
        }`;
      const dynFS=`
        uniform sampler2D u_colors; uniform float u_n, u_opacity; varying float v_id;
        void main(){
          if(length(gl_PointCoord-vec2(0.5))>0.5) discard;
          float u=(v_id+0.5)/u_n;
          vec3 c=texture2D(u_colors, vec2(u,0.5)).rgb;
          gl_FragColor=vec4(c,u_opacity);
        }`;
      const coreVS=`
        attribute vec3 position; attribute vec3 color; uniform float u_size; varying vec3 v_c;
        void main(){ vec4 v=viewMatrix*vec4(position,1.0); gl_Position=projectionMatrix*v;
          float s=length(vec3(modelMatrix[0])); gl_PointSize=u_size*s*(1.0/-v.z); v_c=color; }`;
      const coreFS=`uniform float u_opacity; varying vec3 v_c; void main(){ if(length(gl_PointCoord-vec2(0.5))>0.5) discard; gl_FragColor=vec4(v_c,u_opacity);} `;

      // ----- LOADERS -----
      async function loadCore(m){
        const url=`${ASSET_BASE_URL}/${TRACK_ID}/${m.staticCore.url}`;
        if(url.endsWith(".ply.gz")){
          const ab=await b(url); const inflated=pako.inflate(new Uint8Array(ab));
          const g=new PLYLoader().parse(inflated.buffer);
          if(g.getAttribute("color")){ const c=g.getAttribute("color").array; for(let i=0;i<c.length;i++) c[i]/=255.0; }
          else{ const n=g.getAttribute("position").count; const cols=new Float32Array(n*3); cols.fill(1); g.setAttribute("color", new THREE.BufferAttribute(cols,3)); }
          coreMat=new THREE.ShaderMaterial({uniforms:{u_size:{value:params.size}, u_opacity:{value:params.coreOpacity}}, vertexShader:coreVS, fragmentShader:coreFS, transparent:true, depthWrite:false});
          const pts=new THREE.Points(g,coreMat); pts.frustumCulled=false; return pts;
        }
        throw new Error("Unsupported core format");
      }

      async function loadChunk(path){
        header = await j(`${ASSET_BASE_URL}/${TRACK_ID}/${path}header.json`);
        fps=header.fps; numFrames=header.numFrames; numPoints=header.numPoints;
        qOff.set(...header.quant.offset); qScale.set(...header.quant.scale);
        stridePos=numPoints*3*2; strideCol=numPoints*3;

        [posBuf,colBuf] = await Promise.all([
          b(`${ASSET_BASE_URL}/${TRACK_ID}/${path}positions.bin`),
          b(`${ASSET_BASE_URL}/${TRACK_ID}/${path}colors.bin`)
        ]);
        tmpPosF32 = new Float32Array(numPoints*3);

        const geom=idsGeom(numPoints);
        dynMat=new THREE.ShaderMaterial({
          uniforms:{
            u_positions:{value:null}, u_colors:{value:null},
            u_off:{value:qOff}, u_scale:{value:qScale},
            u_size:{value:params.size}, u_n:{value:numPoints}, u_opacity:{value:params.dynOpacity}
          },
          vertexShader: dynVS, fragmentShader: dynFS,
          transparent:true, depthWrite:false
        });
        dynPoints=new THREE.Points(geom,dynMat); dynPoints.frustumCulled=false;
        updateFrameTextures(0);
        dynMat.uniforms.u_positions.value=dtPos;
        dynMat.uniforms.u_colors.value=dtCol;
        return dynPoints;
      }

      function updateFrameTextures(i){
        const u16 = new Uint16Array(posBuf, i*stridePos, numPoints*3);
        const u8  = new Uint8Array (colBuf, i*strideCol, numPoints*3);
        convertF16Block(u16, tmpPosF32);
        if(!dtPos) dtPos=texRGB32F(tmpPosF32, numPoints);
        else { dtPos.image.data.set(new Float32Array(tmpPosF32.buffer)); dtPos.needsUpdate=true; }
        if(!dtCol) dtCol=texRGB8(u8, numPoints);
        else { dtCol.image.data.set(new Uint8Array(u8)); dtCol.needsUpdate=true; }
      }

      // ----- AUDIO (optional) -----
      async function loadAudio(url){
        try{
          if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)();
          const ab=await b(url);
          if(!ab.byteLength){ audioBuf=null; return; }
          audioBuf=await audioCtx.decodeAudioData(ab.slice(0));
        }catch(e){ console.warn("Audio load error:", e); audioBuf=null; }
      }
      function play(){ if(audioCtx && audioBuf){ const gain=audioCtx.createGain(); gain.gain.value=muted?0:1;
          src=audioCtx.createBufferSource(); src.buffer=audioBuf; src.connect(gain).connect(audioCtx.destination);
          src.start(0, pausedAt); t0=audioCtx.currentTime - pausedAt; src.onended=()=>{ playing=false; pausedAt=0; };
        } t0=audioCtx?audioCtx.currentTime:0; playing=true; }
      function pause(){ if(src){ try{src.stop();}catch{} src.disconnect(); src=null; } if(audioCtx) pausedAt=currentTime(); playing=false; }
      function currentTime(){ return audioCtx ? (playing ? audioCtx.currentTime - t0 : pausedAt) : 0; }

      // ----- FX (lightweight GPGPU seeds from current dyn positions) -----
      function initFX(){
        gpuCompute = new GPUComputationRenderer(numPoints, 1, renderer);
        if(renderer.capabilities.isWebGL2===false) gpuCompute.setDataType(THREE.HalfFloatType);
        const seed=gpuCompute.createTexture(); const p=seed.image.data; for(let i=0;i<p.length;i+=4){p[i]=0;p[i+1]=0;p[i+2]=0;p[i+3]=-1;}
        positionVar = gpuCompute.addVariable("texturePosition", fxPositionShader(), seed);
        gpuCompute.setVariableDependencies(positionVar,[positionVar]);
        const u=positionVar.material.uniforms;
        u.u_time={value:0}; u.u_dt={value:0}; u.u_life={value:params.fxLife};
        u.u_speed={value:params.fxSpeed}; u.u_amp={value:params.curlAmp}; u.u_freq={value:params.curlFreq};
        u.u_spawn={value:dtPos}; u.u_n={value:numPoints};
        const err=gpuCompute.init(); if(err) console.error(err);

        gpgpuMat=new THREE.ShaderMaterial({
          uniforms:{ u_positions:{value:gpuCompute.getCurrentRenderTarget(positionVar).texture}, u_size:{value:params.size}, u_opacity:{value:params.fxOpacity}, u_n:{value:numPoints} },
          vertexShader: dynVS.replace("u_off + u_scale * pN","pN").replace("u_positions","u_positions"),
          fragmentShader: `uniform float u_opacity; void main(){ if(length(gl_PointCoord-vec2(0.5))>0.5) discard; gl_FragColor=vec4(1.,1.,1.,u_opacity); }`,
          transparent:true, depthWrite:false,
          blending: params.additive ? THREE.AdditiveBlending : THREE.NormalBlending
        });
        gpgpuPts=new THREE.Points(dynPoints.geometry, gpgpuMat); gpgpuPts.visible=params.showFX; gpgpuPts.frustumCulled=false;
        mainScene.add(gpgpuPts);
      }
      function fxPositionShader(){
        return `
          uniform float u_time,u_dt,u_life,u_speed,u_amp,u_freq,u_n;
          uniform sampler2D u_spawn;
          float rand(vec2 c){ return fract(sin(dot(c,vec2(12.9898,78.233)))*43758.5453); }
          void main(){
            vec2 uv=gl_FragCoord.xy/resolution.xy;
            vec4 pl=texture2D(texturePosition,uv);
            vec3 pos=pl.xyz; float life=pl.w - u_dt;
            if(life<0.0){
              float id = rand(uv+u_time)*u_n;
              float u=(id+0.5)/u_n;
              pos = texture2D(u_spawn, vec2(u,0.5)).rgb;
              life=u_life;
            }else{
              pos += vec3(0.,0.,1.)*u_speed*u_dt;
              pos += vec3(
                sin((pos.y+u_time)*u_freq),
                sin((pos.z+u_time)*u_freq),
                sin((pos.x+u_time)*u_freq)
              )*u_amp*u_dt*0.1;
            }
            gl_FragColor=vec4(pos,life);
          }`;
      }

      // ----- SCENE/GUI SETUP -----
      function setupScene(){
        const container=document.getElementById("container");
        scene=new THREE.Scene();
        camera=new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 10000); camera.position.z=210;
        renderer=new THREE.WebGLRenderer({antialias:true, alpha:true}); renderer.setSize(innerWidth,innerHeight); renderer.setPixelRatio(devicePixelRatio); renderer.xr.enabled=true; renderer.setClearColor(0x000000,1);
        container.appendChild(renderer.domElement);
        controls=new OrbitControls(camera,renderer.domElement); controls.enableDamping=true; controls.dampingFactor=0.05;
        document.body.appendChild(XRButton.createButton(renderer,{requiredFeatures:["hand-tracking"]}));
        const f=new XRControllerModelFactory(); const g1=renderer.xr.getControllerGrip(0); g1.add(f.createControllerModel(g1)); scene.add(g1); const g2=renderer.xr.getControllerGrip(1); g2.add(f.createControllerModel(g2)); scene.add(g2);
        const h1=renderer.xr.getHand(0); h1.add(new OculusHandModel(h1)); scene.add(h1); const h2=renderer.xr.getHand(1); h2.add(new OculusHandModel(h2)); scene.add(h2);
        mainScene=new THREE.Object3D(); scene.add(mainScene);
        addEventListener("resize",()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight); });
      }

      function setupGUI(){
        const gui=new dat.GUI();
        gui.add(params,"size",1,4000).name("Point Size").onChange(v=>{ if(coreMat)coreMat.uniforms.u_size.value=v; if(dynMat)dynMat.uniforms.u_size.value=v; if(gpgpuMat)gpgpuMat.uniforms.u_size.value=v; });
        gui.add(params,"coreOpacity",0,1).onChange(v=>{ if(coreMat) coreMat.uniforms.u_opacity.value=v; });
        gui.add(params,"dynOpacity",0,1).onChange(v=>{ if(dynMat) dynMat.uniforms.u_opacity.value=v; });
        const fx=gui.addFolder("FX"); fx.add(params,"showFX").onChange(v=>{ if(gpgpuPts) gpgpuPts.visible=v; });
        fx.add(params,"fxLife",1,10).onChange(v=>{ if(positionVar) positionVar.material.uniforms.u_life.value=v; });
        fx.add(params,"fxSpeed",-300,300).onChange(v=>{ if(positionVar) positionVar.material.uniforms.u_speed.value=v; });
        fx.add(params,"fxOpacity",0.01,0.8).onChange(v=>{ if(gpgpuMat) gpgpuMat.uniforms.u_opacity.value=v; });
        fx.add(params,"curlAmp",0,200).onChange(v=>{ if(positionVar) positionVar.material.uniforms.u_amp.value=v; });
        fx.add(params,"curlFreq",0.001,0.05).onChange(v=>{ if(positionVar) positionVar.material.uniforms.u_freq.value=v; });
        fx.add(params,"additive").onChange(v=>{ if(gpgpuMat){ gpgpuMat.blending=v?THREE.AdditiveBlending:THREE.NormalBlending; gpgpuMat.needsUpdate=true; }});
        const pb=gui.addFolder("Playback"); params.playPause=()=>{ playing?pause():play(); }; pb.add(params,"playPause").name("Play / Pause");
        params.mute=()=>{ muted=!muted; if(playing){ pause(); play(); } }; pb.add(params,"mute").name("Mute / Unmute");
        fx.open(); pb.open();
      }

      // ----- TIMELINE / LOOP -----
      function frameIdx(){ if(!header) return 0; const t=currentTime(); return Math.floor(t*fps)%Math.max(1,numFrames); }
      const clock=new THREE.Clock(); let last=0;
      function animate(){
        const t=clock.getElapsedTime(); const dt=t-last; last=t;
        controls.update();
        if(header){
          updateFrameTextures(frameIdx());
          if(dynMat){ dynMat.uniforms.u_positions.value=dtPos; dynMat.uniforms.u_colors.value=dtCol; }
          if(positionVar){ positionVar.material.uniforms.u_time.value=t; positionVar.material.uniforms.u_dt.value=dt; gpuCompute.compute();
            gpgpuMat.uniforms.u_positions.value=gpuCompute.getCurrentRenderTarget(positionVar).texture; }
        }
        renderer.render(scene,camera);
      }

      // ----- BOOT -----
      (async function main(){
        setupScene(); setupGUI();
        const manifest = await j(manifestUrl);
        corePoints = await loadCore(manifest); mainScene.add(corePoints);
        dynPoints = await loadChunk(manifest.dynamic.chunks[0].path); mainScene.add(dynPoints);
        await loadAudio(`${ASSET_BASE_URL}/${TRACK_ID}/${manifest.audio.url}`);
        initFX();
        renderer.setAnimationLoop(animate);
      })().catch(err=>{ console.error(err); const m=document.createElement('div'); m.style.position='absolute'; m.style.top='50%'; m.style.left='50%'; m.style.transform='translate(-50%,-50%)'; m.style.color='#fff'; m.style.font='14px monospace'; m.textContent='Error: '+err.message; document.body.appendChild(m);});
    </script>
  </body>
</html>
