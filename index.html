<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Hologram — Core + Dynamic Points (WebXR)</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"/>
    <style>
      html,body{height:100%;margin:0;background:#000;color:#fff;font-family:Monospace}
      #info{position:absolute;top:10px;left:0;right:0;text-align:center;z-index:100;text-shadow:0 0 5px #000;pointer-events:none}
      #container{width:100vw;height:100vh}
      #err{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);max-width:90%;color:#f66;font:13px/1.4 monospace;white-space:pre-wrap}
    </style>

    <!-- Defaults so it works now; you can override via ?asset= & ?track= or env -->
    <script>
      // Defaults (your R2 public bucket)
      window.ASSET_BASE_URL = "https://pub-e80d414bc7df438287d3018cdba68570.r2.dev";
      window.TRACK_ID       = "demo_v1";

      // Allow URL overrides:  ?asset=<baseUrl>&track=<id>
      try {
        const qs = new URLSearchParams(location.search);
        if (qs.get('asset')) window.ASSET_BASE_URL = qs.get('asset');
        if (qs.get('track')) window.TRACK_ID = qs.get('track');
      } catch {}

      // Friendly error overlay so we don't debug blind
      window.addEventListener('error', e => {
        const d=document.createElement('div'); d.id='err'; d.textContent='JS Error: '+ (e.error?.stack || e.message);
        document.body.appendChild(d);
      });
      window.addEventListener('unhandledrejection', e => {
        const d=document.createElement('div'); d.id='err'; d.textContent='Promise Error: '+ (e.reason?.stack || e.reason);
        document.body.appendChild(d);
      });
    </script>

    <!-- libs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
  </head>

  <body>
    <div id="info">Hologram — Preprocessed Points (Core + Dynamic) • WebXR • GPGPU FX</div>
    <div id="container"></div>

    <!-- Explicit module URLs (no import map) -->
    <script type="module">
      import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js";
      import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/controls/OrbitControls.js";
      import { XRButton } from "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/webxr/XRButton.js";
      import { XRControllerModelFactory } from "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/webxr/XRControllerModelFactory.js";
      import { OculusHandModel } from "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/webxr/OculusHandModel.js";
      import { GPUComputationRenderer } from "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/misc/GPUComputationRenderer.js";
      import { PLYLoader } from "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/loaders/PLYLoader.js";

      // ------- CONFIG -------
      const ASSET_BASE_URL = (window.ASSET_BASE_URL || "").trim();
      const TRACK_ID = (window.TRACK_ID || "").trim();
      const manifestUrl = `${ASSET_BASE_URL}/${TRACK_ID}/manifest.json`;

      // ------- GLOBALS -------
      let scene, camera, renderer, controls, mainScene;
      let corePoints=null, coreMat=null, dynPoints=null, dynMat=null;
      let gpuCompute=null, positionVar=null, gpgpuPts=null, gpgpuMat=null;

      // dynamic buffers/metadata
      let header=null, posBuf=null, colBuf=null;
      let numFrames=0, fps=8, numPoints=0;
      let qOff=new THREE.Vector3(), qScale=new THREE.Vector3();
      let stridePos=0, strideCol=0;
      let dtPos=null, dtCol=null;
      let tmpPosF32=null;

      // audio (optional)
      let audioCtx=null, audioBuf=null, src=null, playing=false, muted=true, t0=0, pausedAt=0;

      const params={
        size: 1300.0,
        coreOpacity: 0.6,
        dynOpacity: 0.5,
        showFX: false,
        fxLife: 5.0, fxSpeed: 40.0, fxOpacity: 0.25,
        curlAmp: 40.0, curlFreq: 0.005,
        additive: true,
        playPause: ()=>{}, mute: ()=>{}
      };

      // ------- UTILS -------
      async function j(url){ const r=await fetch(url); if(!r.ok) throw new Error(`${r.status} ${url}`); return r.json(); }
      async function b(url){ const r=await fetch(url); if(!r.ok) throw new Error(`${r.status} ${url}`); return r.arrayBuffer(); }

      // float16 -> float32
      function f16_to_f32(h){ const s=(h&0x8000)>>15,e=(h&0x7C00)>>10,f=h&0x03FF;
        if(!e) return (s?-1:1)*Math.pow(2,-14)*(f/1024);
        if(e===31) return f?NaN:((s?-1:1)*Infinity);
        return (s?-1:1)*Math.pow(2,e-15)*(1+f/1024);
      }
      function convertF16Block(u16, out){ for(let i=0;i<u16.length;i++) out[i]=f16_to_f32(u16[i]); return out; }

      // RGBA float texture (broader GPU support)
      function texRGBA32F_fromRGBArray(arr, count){
        const rgba = new Float32Array(count * 4);
        for (let i=0, j=0; i<count*3; i+=3, j+=4) {
          rgba[j]=arr[i]; rgba[j+1]=arr[i+1]; rgba[j+2]=arr[i+2]; rgba[j+3]=1.0;
        }
        const t = new THREE.DataTexture(rgba, count, 1, THREE.RGBAFormat, THREE.FloatType);
        t.needsUpdate=true; t.magFilter=t.minFilter=THREE.NearestFilter; t.wrapS=t.wrapT=THREE.ClampToEdgeWrapping; return t;
      }

      function idsGeom(count){ const g=new THREE.BufferGeometry(); const ids=new Float32Array(count); for(let i=0;i<count;i++) ids[i]=i; g.setAttribute("a_id", new THREE.BufferAttribute(ids,1)); return g; }

      // ------- SHADERS -------
      const dynVS=`
        attribute float a_id;
        uniform sampler2D u_positions;
        uniform vec3 u_off, u_scale;
        uniform float u_size, u_n;
        varying float v_id;
        void main(){
          float u=(a_id+0.5)/u_n;
          vec3 pN=texture2D(u_positions, vec2(u,0.5)).rgb;
          vec3 p=u_off + u_scale * pN;
          vec4 v=viewMatrix*vec4(p,1.0);
          gl_Position=projectionMatrix*v;
          float s=length(vec3(modelMatrix[0]));
          gl_PointSize=u_size*s*(1.0/-v.z);
          v_id=a_id;
        }`;
      const dynFS=`
        uniform sampler2D u_colors; uniform float u_n, u_opacity; varying float v_id;
        void main(){
          if(length(gl_PointCoord-vec2(0.5))>0.5) discard;
          float u=(v_id+0.5)/u_n;
          vec3 c=texture2D(u_colors, vec2(u,0.5)).rgb;
          gl_FragColor=vec4(c,u_opacity);
        }`;
      const coreVS=`
        attribute vec3 position; attribute vec3 color; uniform float u_size; varying vec3 v_c;
        void main(){ vec4 v=viewMatrix*vec4(position,1.0); gl_Position=projectionMatrix*v;
          float s=length(vec3(modelMatrix[0])); gl_PointSize=u_size*s*(1.0/-v.z); v_c=color; }`;
      const coreFS=`uniform float u_opacity; varying vec3 v_c; void main(){ if(length(gl_PointCoord-vec2(0.5))>0.5) discard; gl_FragColor=vec4(v_c,u_opacity);} `;

      // ------- LOADERS -------
      async function loadCore(m){
        const url=`${ASSET_BASE_URL}/${TRACK_ID}/${m.staticCore.url}`;
        const ab = await b(url);
        const inflated = pako.inflate(new Uint8Array(ab));
        const text = new TextDecoder().decode(inflated);     // ASCII PLY
        const g = new PLYLoader().parse(text);

        // normalize colors -> Float32 [0..1]
        const colAttr = g.getAttribute("color");
        if (colAttr && colAttr.array instanceof Uint8Array) {
          const n = colAttr.count; const f = new Float32Array(n*3);
          for (let i=0;i<n*3;i++) f[i]=colAttr.array[i]/255;
          g.setAttribute("color", new THREE.BufferAttribute(f,3));
        } else if (!colAttr) {
          const n = g.getAttribute("position").count;
          const ones = new Float32Array(n*3); ones.fill(1);
          g.setAttribute("color", new THREE.BufferAttribute(ones,3));
        }

        coreMat = new THREE.ShaderMaterial({
          uniforms:{ u_size:{value:params.size}, u_opacity:{value:params.coreOpacity} },
          vertexShader: coreVS, fragmentShader: coreFS, transparent:true, depthWrite:false
        });
        const pts = new THREE.Points(g, coreMat); pts.frustumCulled=false;
        return pts;
      }

      async function loadChunk(path){
        header = await j(`${ASSET_BASE_URL}/${TRACK_ID}/${path}header.json`);
        fps=header.fps|0; numFrames=header.numFrames|0; numPoints=header.numPoints|0;
        qOff.set(...header.quant.offset); qScale.set(...header.quant.scale);

        stridePos=numPoints*3*2;   // float16 xyz
        strideCol=numPoints*3;     // u8 xyz
        [posBuf,colBuf] = await Promise.all([
          b(`${ASSET_BASE_URL}/${TRACK_ID}/${path}positions.bin`),
          b(`${ASSET_BASE_URL}/${TRACK_ID}/${path}colors.bin`)
        ]);
        tmpPosF32 = new Float32Array(numPoints*3);

        const geom=idsGeom(numPoints);
        dynMat=new THREE.ShaderMaterial({
          uniforms:{
            u_positions:{value:null}, u_colors:{value:null},
            u_off:{value:qOff}, u_scale:{value:qScale},
            u_size:{value:params.size}, u_n:{value:numPoints}, u_opacity:{value:params.dynOpacity}
          },
          vertexShader: dynVS, fragmentShader: dynFS,
          transparent:true, depthWrite:false
        });
        dynPoints=new THREE.Points(geom,dynMat); dynPoints.frustumCulled=false;

        updateFrameTextures(0);
        dynMat.uniforms.u_positions.value=dtPos;
        dynMat.uniforms.u_colors.value=dtCol;
        return dynPoints;
      }

      function updateFrameTextures(i){
        const u16 = new Uint16Array(posBuf, i*stridePos, numPoints*3);
        const u8  = new Uint8Array (colBuf, i*strideCol, numPoints*3);

        convertF16Block(u16, tmpPosF32);
        if(!dtPos) dtPos = texRGBA32F_fromRGBArray(tmpPosF32, numPoints);
        else {
          const rgba = dtPos.image.data; // Float32Array len = numPoints*4
          for (let p=0,q=0; p<numPoints*3; p+=3, q+=4) {
            rgba[q]=tmpPosF32[p]; rgba[q+1]=tmpPosF32[p+1]; rgba[q+2]=tmpPosF32[p+2]; rgba[q+3]=1.0;
          }
          dtPos.needsUpdate=true;
        }

        if(!dtCol){
          dtCol=new THREE.DataTexture(new Uint8Array(u8), numPoints, 1, THREE.RGBFormat, THREE.UnsignedByteType);
          dtCol.needsUpdate=true; dtCol.magFilter=dtCol.minFilter=THREE.NearestFilter; dtCol.wrapS=dtCol.wrapT=THREE.ClampToEdgeWrapping;
        } else {
          dtCol.image.data.set(new Uint8Array(u8)); dtCol.needsUpdate=true;
        }
      }

      // ------- AUDIO -------
      async function loadAudio(url){
        try{
          if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)();
          const ab=await b(url);
          if(!ab.byteLength){ audioBuf=null; return; }
          audioBuf=await audioCtx.decodeAudioData(ab.slice(0));
        }catch(e){ console.warn("Audio load error:", e); audioBuf=null; }
      }
      function play(){ if(audioCtx && audioBuf){ const gain=audioCtx.createGain(); gain.gain.value=muted?0:1;
          src=audioCtx.createBufferSource(); src.buffer=audioBuf; src.connect(gain).connect(audioCtx.destination);
          src.start(0, pausedAt); t0=audioCtx.currentTime - pausedAt; src.onended=()=>{ playing=false; pausedAt=0; };
        } t0=audioCtx?audioCtx.currentTime:0; playing=true; }
      function pause(){ if(src){ try{src.stop();}catch{} src.disconnect(); src=null; } if(audioCtx) pausedAt=getNow(); playing=false; }

      // use a unique name (no shadowing with libs or vars)
      function getNow(){
        return audioCtx ? (playing ? audioCtx.currentTime - t0 : pausedAt)
                        : performance.now()*0.001;
      }

      // ------- LIGHT FX (optional) -------
      function initFX(){
        gpuCompute = new GPUComputationRenderer(numPoints, 1, renderer);
        if(renderer.capabilities.isWebGL2===false) gpuCompute.setDataType(THREE.HalfFloatType);
        const seed=gpuCompute.createTexture(); const p=seed.image.data; for(let i=0;i<p.length;i+=4){p[i]=0;p[i+1]=0;p[i+2]=0;p[i+3]=-1;}
        positionVar = gpuCompute.addVariable("texturePosition", fxPositionShader(), seed);
        gpuCompute.setVariableDependencies(positionVar,[positionVar]);
        const u=positionVar.material.uniforms;
        u.u_time={value:0}; u.u_dt={value:0}; u.u_life={value:params.fxLife};
        u.u_speed={value:params.fxSpeed}; u.u_amp={value:params.curlAmp}; u.u_freq={value:params.curlFreq};
        u.u_spawn={value:dtPos}; u.u_n={value:numPoints};
        const err=gpuCompute.init(); if(err) console.error(err);

        gpgpuMat=new THREE.ShaderMaterial({
          uniforms:{ u_positions:{value:gpuCompute.getCurrentRenderTarget(positionVar).texture}, u_size:{value:params.size}, u_opacity:{value:params.fxOpacity}, u_n:{value:numPoints} },
          vertexShader: dynVS.replace("u_off + u_scale * pN","pN"),
          fragmentShader: `uniform float u_opacity; void main(){ if(length(gl_PointCoord-vec2(0.5))>0.5) discard; gl_FragColor=vec4(1.,1.,1.,u_opacity); }`,
          transparent:true, depthWrite:false,
          blending: params.additive ? THREE.AdditiveBlending : THREE.NormalBlending
        });
        gpgpuPts=new THREE.Points(dynPoints.geometry, gpgpuMat); gpgpuPts.visible=params.showFX; gpgpuPts.frustumCulled=false;
        mainScene.add(gpgpuPts);
      }
      function fxPositionShader(){
        return `
          uniform float u_time,u_dt,u_life,u_speed,u_amp,u_freq,u_n;
          uniform sampler2D u_spawn;
          float rand(vec2 c){ return fract(sin(dot(c,vec2(12.9898,78.233)))*43758.5453); }
          void main(){
            vec2 uv=gl_FragCoord.xy/resolution.xy;
            vec4 pl=texture2D(texturePosition,uv);
            vec3 pos=pl.xyz; float life=pl.w - u_dt;
            if(life<0.0){
              float id = rand(uv+u_time)*u_n;
              float u=(id+0.5)/u_n;
              pos = texture2D(u_spawn, vec2(u,0.5)).rgb;
              life=u_life;
            }else{
              pos += vec3(0.,0.,1.)*u_speed*u_dt;
              pos += vec3(
                sin((pos.y+u_time)*u_freq),
                sin((pos.z+u_time)*u_freq),
                sin((pos.x+u_time)*u_freq)
              )*u_amp*u_dt*0.1;
            }
            gl_FragColor=vec4(pos,life);
          }`;
      }

      // ------- SCENE / GUI -------
      function setupScene(){
        const container=document.getElementById("container");
        scene=new THREE.Scene();
        camera=new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 10000); camera.position.z=210;
        renderer=new THREE.WebGLRenderer({antialias:true, alpha:true}); renderer.setSize(innerWidth,innerHeight); renderer.setPixelRatio(devicePixelRatio); renderer.xr.enabled=true; renderer.setClearColor(0x000000,1);
        container.appendChild(renderer.domElement);
        controls=new OrbitControls(camera,renderer.domElement); controls.enableDamping=true; controls.dampingFactor=0.05;
        document.body.appendChild(XRButton.createButton(renderer,{requiredFeatures:["hand-tracking"]}));
        const f=new XRControllerModelFactory(); const g1=renderer.xr.getControllerGrip(0); g1.add(f.createControllerModel(g1)); scene.add(g1); const g2=renderer.xr.getControllerGrip(1); g2.add(f.createControllerModel(g2)); scene.add(g2);
        const h1=renderer.xr.getHand(0); h1.add(new OculusHandModel(h1)); scene.add(h1); const h2=renderer.xr.getHand(1); h2.add(new OculusHandModel(h2)); scene.add(h2);
        mainScene=new THREE.Object3D(); scene.add(mainScene);
        addEventListener("resize",()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight); });
      }

      function setupGUI(){
        const gui=new dat.GUI();
        gui.add(params,"size",1,4000).name("Point Size").onChange(v=>{ if(coreMat)coreMat.uniforms.u_size.value=v; if(dynMat)dynMat.uniforms.u_size.value=v; if(gpgpuMat)gpgpuMat.uniforms.u_size.value=v; });
        gui.add(params,"coreOpacity",0,1).onChange(v=>{ if(coreMat) coreMat.uniforms.u_opacity.value=v; });
        gui.add(params,"dynOpacity",0,1).onChange(v=>{ if(dynMat) dynMat.uniforms.u_opacity.value=v; });
        const fx=gui.addFolder("FX"); fx.add(params,"showFX").onChange(v=>{ if(gpgpuPts) gpgpuPts.visible=v; });
        fx.add(params,"fxLife",1,10).onChange(v=>{ if(positionVar) positionVar.material.uniforms.u_life.value=v; });
        fx.add(params,"fxSpeed",-300,300).onChange(v=>{ if(positionVar) positionVar.material.uniforms.u_speed.value=v; });
        fx.add(params,"fxOpacity",0.01,0.8).onChange(v=>{ if(gpgpuMat) gpgpuMat.uniforms.u_opacity.value=v; });
        fx.add(params,"curlAmp",0,200).onChange(v=>{ if(positionVar) positionVar.material.uniforms.u_amp.value=v; });
        fx.add(params,"curlFreq",0.001,0.05).onChange(v=>{ if(positionVar) positionVar.material.uniforms.u_freq.value=v; });
        fx.add(params,"additive").onChange(v=>{ if(gpgpuMat){ gpgpuMat.blending=v?THREE.AdditiveBlending:THREE.NormalBlending; gpgpuMat.needsUpdate=true; }});
        const pb=gui.addFolder("Playback"); params.playPause=()=>{ playing?pause():play(); }; pb.add(params,"playPause").name("Play / Pause");
        params.mute=()=>{ muted=!muted; if(playing){ pause(); play(); } }; pb.add(params,"mute").name("Mute / Unmute");
        fx.open(); pb.open();
      }

      // ------- TIMELINE / LOOP -------
      function frameIdx(){ if(!header) return 0; const t=getNow(); return Math.floor(t*fps)%Math.max(1,numFrames); }
      const clock=new THREE.Clock(); let last=0;
      function animate(){
        const t=clock.getElapsedTime(); const dt=t-last; last=t;
        controls.update();
        if(header){
          updateFrameTextures(frameIdx());
          if(dynMat){ dynMat.uniforms.u_positions.value=dtPos; dynMat.uniforms.u_colors.value=dtCol; }
          if(positionVar){ positionVar.material.uniforms.u_time.value=t; positionVar.material.uniforms.u_dt.value=dt; gpuCompute.compute();
            gpgpuMat.uniforms.u_positions.value=gpuCompute.getCurrentRenderTarget(positionVar).texture; }
        }
        renderer.render(scene,camera);
      }

      // ------- BOOT -------
      (async function main(){
        setupScene(); setupGUI();
        const manifest = await j(manifestUrl);
        corePoints = await loadCore(manifest); mainScene.add(corePoints);
        dynPoints  = await loadChunk(manifest.dynamic.chunks[0].path); mainScene.add(dynPoints);
        await loadAudio(`${ASSET_BASE_URL}/${TRACK_ID}/${manifest.audio.url}`);
        if (numPoints>0) initFX();
        renderer.setAnimationLoop(animate);
      })().catch(err=>{
        const d=document.createElement('div'); d.id='err'; d.textContent='Init Error: '+(err.stack||err.message);
        document.body.appendChild(d); console.error(err);
      });
    </script>
  </body>
</html>
