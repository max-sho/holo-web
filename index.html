<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Hologram — Core + Dynamic (Debug + GUI)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <style>
    html,body{height:100%;margin:0;background:#000;color:#fff;font-family:Monospace}
    #info{position:absolute;top:10px;left:0;right:0;text-align:center;z-index:10;pointer-events:none}
    #container{width:100vw;height:100vh}
    #err{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);max-width:90%;color:#f66;font:13px monospace;white-space:pre-wrap}
    #log{position:fixed;left:10px;bottom:10px;z-index:20;font:12px monospace;color:#ddd;white-space:pre;pointer-events:none}
    .ok{color:#9f9}.bad{color:#f99}
    .hidden{display:none}
  </style>

  <!-- Import map so addons can `import 'three'` -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.167.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.167.0/examples/jsm/"
    }
  }
  </script>

  <!-- Defaults (override via ?asset=&track=) -->
  <script>
    window.ASSET_BASE_URL = "https://pub-e80d414bc7df438287d3018cdba68570.r2.dev";
    window.TRACK_ID       = "demo_v1";
    try {
      const q = new URLSearchParams(location.search);
      if (q.get('asset')) window.ASSET_BASE_URL = q.get('asset');
      if (q.get('track')) window.TRACK_ID = q.get('track');
    } catch {}
    // Error overlays
    addEventListener('error', e=>{
      const d=document.createElement('div'); d.id='err';
      d.textContent='JS Error: '+(e.error?.stack || e.message);
      document.body.appendChild(d);
    });
    addEventListener('unhandledrejection', e=>{
      const d=document.createElement('div'); d.id='err';
      d.textContent='Promise Error: '+(e.reason?.stack || e.reason);
      document.body.appendChild(d);
    });
  </script>

  <!-- libs -->
  <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
</head>
<body>
  <div id="info">Hologram — Preprocessed Points (Core + Dynamic) • Debug</div>
  <div id="container"></div>
  <div id="log"></div>

  <script type="module">
    // ---------- status log ----------
    const logEl=document.getElementById('log');
    const log=(m,ok=true)=>{ const s=document.createElement('div'); s.className=ok?'ok':'bad'; s.textContent=(ok?'✓ ':'✗ ')+m; logEl.appendChild(s); console[ok?'log':'warn'](m); };

    if (!HTMLScriptElement.supports?.('importmap')) {
      log('Browser lacks importmap support — use recent Chrome/Edge/Safari.', false);
    }

    log('boot');

    // ---------- modules ----------
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { XRButton } from "three/addons/webxr/XRButton.js";
    import { XRControllerModelFactory } from "three/addons/webxr/XRControllerModelFactory.js";
    import { OculusHandModel } from "three/addons/webxr/OculusHandModel.js";
    import { PLYLoader } from "three/addons/loaders/PLYLoader.js";
    log('modules ok');

    // ---------- config ----------
    const ASSET_BASE_URL=(window.ASSET_BASE_URL||'').trim();
    const TRACK_ID=(window.TRACK_ID||'').trim();
    const manifestUrl=`${ASSET_BASE_URL}/${TRACK_ID}/manifest.json`;

    // ---------- globals ----------
    let scene,camera,renderer,controls,mainScene;
    let corePoints=null,coreMat=null,dynPoints=null,dynMat=null;
    let header=null,posBuf=null,colBuf=null;
    let numFrames=0,fps=8,numPoints=0;
    let qOff=new THREE.Vector3(), qScale=new THREE.Vector3();
    let stridePos=0,strideCol=0;
    let dtPos=null,dtCol=null,tmpPosF32=null;

    const params={ size:1800, coreOpacity:0.9, dynOpacity:0.9 };

    // ---------- utils ----------
    async function j(url){ const r=await fetch(url); if(!r.ok) throw new Error(`${r.status} ${url}`); return r.json(); }
    async function b(url){ const r=await fetch(url); if(!r.ok) throw new Error(`${r.status} ${url}`); return r.arrayBuffer(); }

    function f16_to_f32(h){ const s=(h&0x8000)>>15,e=(h&0x7C00)>>10,f=h&0x03FF;
      if(!e) return (s?-1:1)*Math.pow(2,-14)*(f/1024);
      if(e===31) return f?NaN:((s?-1:1)*Infinity);
      return (s?-1:1)*Math.pow(2,e-15)*(1+f/1024);
    }
    function convertF16Block(u16,out){ for(let i=0;i<u16.length;i++) out[i]=f16_to_f32(u16[i]); return out; }

    function texRGBA32F_fromRGBArray(arr,count){
      const rgba=new Float32Array(count*4);
      for(let i=0,j=0;i<count*3;i+=3,j+=4){ rgba[j]=arr[i]; rgba[j+1]=arr[i+1]; rgba[j+2]=arr[i+2]; rgba[j+3]=1.0; }
      const t=new THREE.DataTexture(rgba,count,1,THREE.RGBAFormat,THREE.FloatType);
      t.needsUpdate=true; t.magFilter=t.minFilter=THREE.NearestFilter; t.wrapS=t.wrapT=THREE.ClampToEdgeWrapping; return t;
    }
    function idsGeom(n){ const g=new THREE.BufferGeometry(); const ids=new Float32Array(n); for(let i=0;i<n;i++) ids[i]=i; g.setAttribute('a_id',new THREE.BufferAttribute(ids,1)); return g; }

    function fitCameraToObject(obj,pad=1.3){
      obj.geometry.computeBoundingSphere?.();
      const bs=obj.geometry.boundingSphere;
      if(!bs){ log('no bounding sphere',false); return; }
      const r=bs.radius*pad;
      camera.position.set(bs.center.x,bs.center.y,bs.center.z + r*2.8);
      camera.near=Math.max(0.01,r/100); camera.far=r*25; camera.updateProjectionMatrix();
      controls.target.copy(bs.center);
      log(`camera fit r=${r.toFixed(2)}`);
    }

    // ---------- shaders ----------
    const dynVS=`attribute float a_id; uniform sampler2D u_positions; uniform vec3 u_off,u_scale; uniform float u_size,u_n; varying float v_id;
      void main(){ float u=(a_id+0.5)/u_n; vec3 pN=texture2D(u_positions,vec2(u,0.5)).rgb; vec3 p=u_off+u_scale*pN;
      vec4 v=viewMatrix*vec4(p,1.0); gl_Position=projectionMatrix*v; float s=length(vec3(modelMatrix[0])); gl_PointSize=u_size*s*(1.0/-v.z); v_id=a_id; }`;
    const dynFS=`uniform sampler2D u_colors; uniform float u_n,u_opacity; varying float v_id;
      void main(){ if(length(gl_PointCoord-vec2(0.5))>0.5) discard; float u=(v_id+0.5)/u_n; vec3 c=texture2D(u_colors,vec2(u,0.5)).rgb; gl_FragColor=vec4(c,u_opacity); }`;
    const coreVS=`attribute vec3 position; attribute vec3 color; uniform float u_size; varying vec3 v_c;
      void main(){ vec4 v=viewMatrix*vec4(position,1.0); gl_Position=projectionMatrix*v; float s=length(vec3(modelMatrix[0])); gl_PointSize=u_size*s*(1.0/-v.z); v_c=color; }`;
    const coreFS=`uniform float u_opacity; varying vec3 v_c; void main(){ if(length(gl_PointCoord-vec2(0.5))>0.5) discard; gl_FragColor=vec4(v_c,u_opacity);} `;

    // ---------- loaders ----------
    async function loadCore(m){
      const url=`${ASSET_BASE_URL}/${TRACK_ID}/${m.staticCore.url}`;
      const ab=await b(url);
      const inflated=pako.inflate(new Uint8Array(ab));
      const text=new TextDecoder().decode(inflated);  // ASCII PLY
      const g=new PLYLoader().parse(text);

      const ca=g.getAttribute('color');
      if(ca && ca.array instanceof Uint8Array){
        const n=ca.count; const f=new Float32Array(n*3);
        for(let i=0;i<n*3;i++) f[i]=ca.array[i]/255;
        g.setAttribute('color',new THREE.BufferAttribute(f,3));
      } else if(!ca){
        const n=g.getAttribute('position').count; const ones=new Float32Array(n*3); ones.fill(1);
        g.setAttribute('color',new THREE.BufferAttribute(ones,3));
      }

      coreMat=new THREE.ShaderMaterial({
        uniforms:{ u_size:{value:params.size}, u_opacity:{value:params.coreOpacity} },
        vertexShader: coreVS, fragmentShader: coreFS, transparent:true, depthWrite:false
      });
      const pts=new THREE.Points(g,coreMat); pts.frustumCulled=false;
      return pts;
    }

    async function loadChunk(path){
      header = await j(`${ASSET_BASE_URL}/${TRACK_ID}/${path}header.json`);
      const {numFrames:fN=0,fps:fpsIn=8,numPoints:nPts=0,quant}=header;
      numFrames=fN; fps=fpsIn; numPoints=nPts;
      qOff.set(...quant.offset); qScale.set(...quant.scale);

      const [pb,cb]=await Promise.all([
        b(`${ASSET_BASE_URL}/${TRACK_ID}/${path}positions.bin`),
        b(`${ASSET_BASE_URL}/${TRACK_ID}/${path}colors.bin`)
      ]);
      posBuf=pb; colBuf=cb;
      stridePos=numPoints*3*2; strideCol=numPoints*3;
      tmpPosF32=new Float32Array(numPoints*3);

      const geom=idsGeom(numPoints);
      dynMat=new THREE.ShaderMaterial({
        uniforms:{
          u_positions:{value:null}, u_colors:{value:null},
          u_off:{value:qOff}, u_scale:{value:qScale},
          u_size:{value:params.size}, u_n:{value:numPoints}, u_opacity:{value:params.dynOpacity}
        },
        vertexShader: dynVS, fragmentShader: dynFS, transparent:true, depthWrite:false
      });
      dynPoints=new THREE.Points(geom,dynMat); dynPoints.frustumCulled=false;

      updateFrameTextures(0);
      dynMat.uniforms.u_positions.value=dtPos;
      dynMat.uniforms.u_colors.value   =dtCol;
      return dynPoints;
    }

    function updateFrameTextures(i){
      const u16=new Uint16Array(posBuf, i*stridePos, numPoints*3);
      const u8 =new Uint8Array (colBuf, i*strideCol, numPoints*3);
      convertF16Block(u16,tmpPosF32);
      if(!dtPos) dtPos=texRGBA32F_fromRGBArray(tmpPosF32,numPoints);
      else {
        const rgba=dtPos.image.data;
        for(let p=0,q=0;p<numPoints*3;p+=3,q+=4){ rgba[q]=tmpPosF32[p]; rgba[q+1]=tmpPosF32[p+1]; rgba[q+2]=tmpPosF32[p+2]; rgba[q+3]=1.0; }
        dtPos.needsUpdate=true;
      }
      if(!dtCol){
        dtCol=new THREE.DataTexture(new Uint8Array(u8),numPoints,1,THREE.RGBFormat,THREE.UnsignedByteType);
        dtCol.needsUpdate=true; dtCol.magFilter=dtCol.minFilter=THREE.NearestFilter; dtCol.wrapS=dtCol.wrapT=THREE.ClampToEdgeWrapping;
      } else {
        dtCol.image.data.set(new Uint8Array(u8)); dtCol.needsUpdate=true;
      }
    }

    // ---------- scene ----------
    function setupScene(){
      const container=document.getElementById('container');
      scene=new THREE.Scene();
      camera=new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.01, 1e6);
      camera.position.set(0,0,3);
      renderer=new THREE.WebGLRenderer({antialias:true,alpha:true});
      renderer.setPixelRatio(devicePixelRatio); renderer.setSize(innerWidth,innerHeight);
      renderer.xr.enabled=true; renderer.setClearColor(0x000000,1);
      container.appendChild(renderer.domElement);
      controls=new OrbitControls(camera,renderer.domElement);
      controls.enableDamping=true; controls.dampingFactor=0.05;
      document.body.appendChild(XRButton.createButton(renderer,{requiredFeatures:["hand-tracking"]}));
      const xmf=new XRControllerModelFactory(); const g1=renderer.xr.getControllerGrip(0); g1.add(xmf.createControllerModel(g1)); scene.add(g1);
      const g2=renderer.xr.getControllerGrip(1); g2.add(xmf.createControllerModel(g2)); scene.add(g2);
      const h1=renderer.xr.getHand(0); h1.add(new OculusHandModel(h1)); scene.add(h1);
      const h2=renderer.xr.getHand(1); h2.add(new OculusHandModel(h2)); scene.add(h2);
      mainScene=new THREE.Object3D(); scene.add(mainScene);
      addEventListener('resize',()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight); });
    }

    // ---------- GUI ----------
    function setupGUI() {
      const gui = new dat.GUI();

      const sizeCtrl = gui.add(params, "size", 50, 4000).name("Point Size");
      sizeCtrl.onChange(v => {
        if (coreMat) coreMat.uniforms.u_size.value = v;
        if (dynMat)  dynMat.uniforms.u_size.value  = v;
      });

      const coreCtrl = gui.add(params, "coreOpacity", 0.0, 1.0).name("coreOpacity");
      coreCtrl.onChange(v => { if (coreMat) coreMat.uniforms.u_opacity.value = v; });

      const dynCtrl  = gui.add(params, "dynOpacity", 0.0, 1.0).name("dynOpacity");
      dynCtrl.onChange(v => { if (dynMat) dynMat.uniforms.u_opacity.value = v; });

      const visFolder = gui.addFolder("Visibility");
      const vis = { core:true, dynamic:true };
      visFolder.add(vis, "core").onChange(v => { if (corePoints) corePoints.visible = v; });
      visFolder.add(vis, "dynamic").onChange(v => { if (dynPoints)  dynPoints.visible  = v; });
      visFolder.open();

      // Playback (simple)
      const pb = { play:true, frame:0, fps };
      const pbFolder = gui.addFolder("Playback");
      pbFolder.add(pb, "play").name("Play/Pause");
      pbFolder.add(pb, "fps", 1, 60, 1).name("FPS").onChange(v => { fps = v|0; });
      const frameCtrl = pbFolder.add(pb, "frame", 0, Math.max(0, numFrames-1), 1).name("Frame");
      frameCtrl.onChange(i => {
        if (!pb.play && header) {
          updateFrameTextures(i|0);
          if (dynMat) {
            dynMat.uniforms.u_positions.value = dtPos;
            dynMat.uniforms.u_colors.value    = dtCol;
          }
        }
      });
      pbFolder.open();

      // Tie “play” into our frame selector
      const _frameIdx = frameIdx;
      window.frameIdx = function () {
        return pb.play ? _frameIdx() : (pb.frame|0);
      };

      // quick toggle
      window.addEventListener("keydown", e => { if (e.key.toLowerCase() === "g") gui.domElement.classList.toggle("hidden"); });
    }

    // ---------- loop ----------
    const clock=new THREE.Clock(); let last=0;
    function getNow(){ return performance.now()*0.001; }
    function frameIdx(){ if(!header) return 0; const t=getNow(); return Math.floor(t*fps)%Math.max(1,numFrames); }
    function animate(){
      const t=clock.getElapsedTime(); const dt=t-last; last=t;
      controls.update();
      if(header){
        updateFrameTextures(frameIdx());
        if(dynMat){ dynMat.uniforms.u_positions.value=dtPos; dynMat.uniforms.u_colors.value=dtCol; }
      }
      renderer.render(scene,camera);
    }

    // ---------- boot ----------
    (async function main(){
      setupScene();

      log('fetch manifest...');
      const manifest=await j(manifestUrl);      log('manifest ok');

      log('load core...');
      corePoints=await loadCore(manifest);
      mainScene.add(corePoints);
      const nCore=corePoints.geometry.getAttribute('position').count|0;
      log(`core ok (${nCore} pts)`);
      fitCameraToObject(corePoints,1.3);

      log('load first chunk...');
      dynPoints=await loadChunk(manifest.dynamic.chunks[0].path);
      mainScene.add(dynPoints);
      log(`chunk ok (${numPoints} dyn pts/frame @ ${fps} fps)`);

      setupGUI();

      log('start loop');
      renderer.setAnimationLoop(animate);
    })().catch(err=>{
      const d=document.createElement('div'); d.id='err'; d.textContent='Init Error: '+(err.stack||err.message); document.body.appendChild(d);
      log('init failed: '+err.message,false);
      console.error(err);
    });
  </script>
</body>
</html>
